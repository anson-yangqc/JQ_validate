\bis\b 【\b是单词边界只匹配 is 不匹配this】
正则里的转义使用\ 
http:\/\/.+\.jpg  【】匹配http://开头，.jpg结尾的字符串 
【】转义使用\
\d{4} 【】表示4个数字
\d{4}[/-] 【】表示 /或者-
\d{4}[/-]\d{2}[/-]\d{2} 【】匹配2006/02/03 ；12345/23/45678
^\d{4}[/-]\d{2}[/-]\d{2}$ 【】^表示开头$表示结尾
var reg = /\d{4}/g   
'2006/02/03'.replace(reg,'X') 结果为 "X/02/03"
==========================分割线====================================

JS中正则表达式
【字面量方式】
var reg = //g 或者 var reg = //【】两种模板，在两个//中间写正则匹配
如var reg = /\bis\b/g
'He is a boy. This is a dog. Where is she?'.replace(reg,'IS')
【构造函数方式】
var reg = new RegExp('\\bis\\b','g')
如var reg = new RegExp('\\bis\\b','g') 【】传入正则语法需要转义，所以出现两个斜杠
'He is a boy. This is a dog. Where is she?'.replace(reg,'IS')

====================================================================

修饰符
g：默认false ,权威搜索，不添加搜索第一个则停止，添加则匹配所有
i：默认false ,默认大小写敏感，添加则忽略大小写匹配
m：默认false ,表示多行搜索
如var reg = /\bis\b/gi
'He is a boy.Is he?'.replace(reg,'IS')

====================================================================

正则表达式由两种基本字符类型组成：
1原义文本字符：例如写a就是a，abc就是abc，123就是匹配123
2元字符：就是正则表达式中有特殊含义的非字母字符，
例如 \b 是匹配单词边界
* 
+ 
? 
$ 表示结尾
^ 表示开始 或者取反
. 
| 
\ 
() 
{} 
[] 表示或
\t 水平制表符
\v 垂直制表符
\n 换行符
\r 回车符
\0 空字符
\f 换页符
\cX 与X对应的控制字符 (crrl + X)

====================================================================

例如ab\t
使用元字符[]来构建一个简单的类
所谓的类是指符合某些特性的对象，一个泛指，而不是指某个字符
表达式[abc]把字符a或字符b或字符c归为一类，表达式可以匹配这类的字符；
如：var reg = /[abc]/g
'a1b2c3d4e5'.replace(reg,'xxx') 结果：xxx1xxx2xxx3d4e5

====================================================================

字符类取反
使用元字符^创建反向类/负向类
反向类的意思是不属于某类的内容
如 [^abc] 表示不是字符a或字符b或字符c的内容
如：var reg = /[^abc]/g
'a1b2c3d4e5'.replace(reg,'xxx') 结果：axxxbxxxcxxxxxxxxxxxxxxx

====================================================================

范围类
使用字符类匹配数字 [0123456789] 这样匹配所有的数字的写法不太友好
所以可使用 [a-z]来连接两个字符表示 从a到z的任意字符,包含a和z本身
如 var reg = /[a-z]/g
'a1b2d3x4z9'.replace(reg,'L')  结果为 L1L2L3L4L9
如[a-zA-Z]表示小写a到z和大写A到Z
var reg = /[a-z0-9]/gi

如'A1b2d3x4z9'.replace(reg,'L') 结果为 LLLLLLLLLL
如 var reg = /[0-9]/g
'2019-09-02'.replace(reg,'L') 结果为 LLLL-LL-LL
如 var reg = /[0-9-]/g
'2019-09-02'.replace(reg,'L') 结果为 LLLLLLLLLL

====================================================================

预定义类
正则表达式提供 预定义类 来匹配常见的字符类
. 等于 [^\r\n] 此为任意字符，就是除了回车符和换行符之外的所有字符
\d 等于 [0-9] 数字字符
\D 等于 [^0-9] 非数字字符
\s 等于 [\t\n\x0B\f\r] 空白符
\S 等于 [^\t\n\x0B\f\r]非空白符
\w 等于 [a-zA-Z_0-9]单词字符（字母、数字下划线）
\W 等于 [^a-zA-Z_0-9]非单词字符

例如 匹配一个 ab+数字+任意字符 的字符串
var reg = /[ab0-9^\r\n]/g    'ab2019-09-02'.replace(reg,'L') 结果为 LLLLLL-LL-LL
var reg = /[ab0-9-]/g        
'ab2019-09-02'.replace(reg,'L') 结果为 LLLLLLLLLLLL
var reg = /[^\r\n]/g
         'ab2019-09-02'.replace(reg,'L') 结果为 LLLLLLLLLLLL
var reg = /ab[0-9]/g         'ab2019-09-02'.replace(reg,'L') 结果为 L019-09-02
var reg = /ab[0-9][^\r\n]/g  'ab2019-09-02'.replace(reg,'L') 结果为 L19-09-02
var reg = /ab\d./g           'ab2019-09-02'.replace(reg,'L') 结果为 L19-09-02
var reg = /[ab0-9]./g        
'ab2019-09-02'.replace(reg,'L')
 结果为 LLL-L-L

====================================================================

边界
^ 以xxx开始，在字符类中表示取反,元字符在不同的场景有不同的含义（不在中括号里面，就不是取反的意思）
$ 以xxx结束
\b 单词边界
\B 非单词边界
var reg = /\Bis\b/g

'This is a dog'.replace(reg,'X') 结果为 "ThX is a dog"
如 var reg = /@./g
'@123@abc@'.replace(reg,'Q') 结果为 "Q23Qbc@"
如 var reg = /^@./g
'@123@abc@'.replace(reg,'Q') 结果为 "Q23@abc@"
如 var reg = /.@/g
'@123@abc@'.replace(reg,'Q') 结果为 "@12QabQ"
如 var reg = /.@$/g
'@123@abc@'.replace(reg,'Q') 结果为 "@123@abQ"
如var reg = /^@\d/gm
"@123
@456
@780
".replace(reg,X) 结果为 "
X23
X56
X89
"

====================================================================
量词
? 出现零次或者一次（最多出现一次）如 \d?
+ 出现一次或者多次 （至少出现一次）如\d+
* 出现零次或多次（任意次）如\d*
{n} 出现n次 如\d{2}
{n,m}出现n到m次 \d{5,10} 最少5次最多10次; 最多10次{0,10}
{n,}至少出现n次 \d{5,} 

====================================================================

贪婪模式（默认这个模式）
var reg = /\d{3,6}/g
'12345678'.replace(reg,'X') 结果为 "X78"

非贪婪模式。只需要在量词后面加上？即可转为使用此模式
让正则表达式尽可能少的匹配，也就是说一旦成功匹配就不再继续尝试。
如 var reg = /\d{3,5}?/g
'123456789'.match(reg)  结果为 ["123", "456", "789"]
var reg = /\d{3,5}?/g   
'1234567891'.replace(reg,'x') 结果为 "xxx1"
var reg = /\d{3,5}/g    
'12345678912'.replace(reg,'x')结果为 "xx2"
var reg = /\d{3,5}/g    
'123456789'.replace(reg,'x')
  结果为 "xx"


=======================================
前瞻
var reg = /\w(?=\d)/g
   'a2*3'.replace(reg,'X')  结果为 "X2*3"
var reg = /\w(?=\D)/g
   'a2*3'.replace(reg,'X')  结果为 "aX*3"
var reg = /\w(?=\d)/g
   'a2*33'.replace(reg,'X')  结果为 "X2*X3"
var reg = /\w(?=\D)/g
   'a2*33'.replace(reg,'X')  结果为 "aX*33"
var reg = /\w(?!\d)/g   'a2*34vv'.replace(reg,'X') 结果为 "aX*3XXX"

=======================================

test和exec方法
test 用于测试字符串参数中是否存在匹配正则表达式模式的字符串，返回true或false
如校验邮箱手机是否正确：var reg = /\w/g ; reg.test('a') ; 返回执行会觉得结果不一样，因为lastIndex的问题，每次执行会在上一次的索引开始匹配
除非每次使用都用新的对象，但会增加内存开销 例如/\w/g.test('a')

exec 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果

=======================================

search方法
用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串
返回第一个匹配结果index，查找不到返回 -1
该方法不执行全局匹配，它将忽略标志 g,并且总是从字符串的开始进行检索
多次执行都会从头开始匹配,与test不一样

'a1b2c3d1'.search('1') 结果为 1 会尝试隐式转为正则
'a1b2c3d1'.search(1)   结果为 1 会尝试隐式转为正则
'a1b2c3d1'.search('10') 结果为 -1 会尝试隐式转为正则
'a1b2c3d1'.search(/3/)   结果为 5  传入正则表达式
 
=======================================

match方法
该方法将检索字符串，以找到一个或多个与regexp匹配的文本，得到数组
regexp是否具有标志g 对结果影响很大
var reg = /\d(\w)\d/g
'$1a2b3c4d5e'.match(reg) 结果为 ["1a2", "3c4"]  用了g才会返回所有匹配的结果

=======================================

split方法
字符串裁剪成数组的方法 如'a,b,c,d'.split(',') 结果为 ['a','b','c','d']
'as1b2c3d'.split(/\d/)    结果为 ['as','b','c','d']
'as-b2c3d'.split(/[\d-]/) 结果为 ['as','b','c','d']
=======================================

replace
'a1b2c1'.replace(/\d/g,function(match,index,orgin){
	
    return parseInt(match) +1

})
结果为 "a2b3c2"

'a1b2c1'.replace(/(\d)(\w)(\d)/g,function(match,group1,group2,group3,index,orgin){
	
return group2

})
结果为 "abc1"














































































